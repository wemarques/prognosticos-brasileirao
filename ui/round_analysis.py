"""
Interface de An√°lise de Rodadas
Integra todos os m√≥dulos para an√°lise completa por rodada
"""

import streamlit as st
from typing import Dict, List, Optional
from datetime import datetime

try:
    from data.round_manager import RoundManager
    from data.odds_collector import OddsCollector
    from analysis.comparison import PrognosisComparator
    from models.auto_calibration import ModelCalibrator
    from analysis.calculator import PrognosisCalculator
    from data.processor import DataProcessor
    from data.collector import FootballDataCollector
except ImportError as e:
    st.error(f"Erro ao importar m√≥dulos: {e}")


def show_round_analysis(rodada: int):
    """
    Exibe an√°lise completa de uma rodada
    
    Args:
        rodada: N√∫mero da rodada (1-38)
    """
    
    st.header(f"üèÜ An√°lise da Rodada {rodada}")
    
    try:
        # Inicializar gerenciador de rodadas
        round_mgr = RoundManager()
        
        # Buscar jogos da rodada
        with st.spinner(f"Buscando jogos da rodada {rodada}..."):
            round_status = round_mgr.get_round_status(rodada)
        
        if not round_status['matches']:
            st.warning(f"‚ö†Ô∏è Nenhum jogo encontrado para a rodada {rodada}")
            return
        
        # Exibir status da rodada
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("Total de Jogos", round_status['total_matches'])
        
        with col2:
            st.metric("Finalizados", round_status['finished'], 
                     delta=None if round_status['finished'] == 0 else "‚úÖ")
        
        with col3:
            st.metric("Agendados", round_status['scheduled'],
                     delta=None if round_status['scheduled'] == 0 else "üìÖ")
        
        with col4:
            st.metric("Em Andamento", round_status['in_play'],
                     delta=None if round_status['in_play'] == 0 else "‚öΩ")
        
        st.markdown("---")
        
        # Determinar tipo de an√°lise
        if round_status['is_complete']:
            # RODADA PASSADA: Compara√ß√£o progn√≥stico vs realidade
            show_past_round_analysis(rodada, round_status['matches'])
        elif round_status['scheduled'] > 0:
            # RODADA FUTURA: Progn√≥sticos
            show_future_round_analysis(rodada, round_status['matches'])
        else:
            # RODADA EM ANDAMENTO
            st.info("‚öΩ Rodada em andamento! Aguarde finaliza√ß√£o para an√°lise completa.")
            show_live_round_status(round_status['matches'])
    
    except Exception as e:
        st.error(f"‚ùå Erro ao analisar rodada: {e}")
        with st.expander("üêõ Detalhes do Erro"):
            import traceback
            st.code(traceback.format_exc())


def show_past_round_analysis(rodada: int, matches: List[Dict]):
    """
    An√°lise de rodada passada: Compara√ß√£o progn√≥stico vs realidade
    
    Args:
        rodada: N√∫mero da rodada
        matches: Lista de jogos finalizados
    """
    
    st.subheader("üìä An√°lise Retrospectiva: Progn√≥stico vs Realidade")
    
    st.info(f"‚úÖ Rodada {rodada} finalizada! Comparando progn√≥sticos com resultados reais...")
    
    # Inicializar comparador e calibrador
    comparator = PrognosisComparator()
    calibrator = ModelCalibrator()
    
    # Processar cada jogo
    all_comparisons = []
    
    for match in matches:
        with st.expander(f"‚öΩ {match['home_team']['name']} {match['score']['home']}-{match['score']['away']} {match['away_team']['name']}"):
            
            # Gerar progn√≥stico (como teria sido)
            try:
                prognosis = generate_prognosis_for_match(match)
                
                # Comparar com resultado real
                real_result = {
                    'home_score': match['score']['home'],
                    'away_score': match['score']['away']
                }
                
                match_info = {
                    'home_team': match['home_team']['name'],
                    'away_team': match['away_team']['name'],
                    'date': match['date'],
                    'round': rodada,
                    'referee': match.get('referee', 'N/A')
                }
                
                comparison = comparator.compare_match(prognosis, real_result, match_info)
                all_comparisons.append(comparison)
                
                # Exibir compara√ß√£o
                display_match_comparison(comparison)
            
            except Exception as e:
                st.error(f"Erro ao processar jogo: {e}")
    
    # Relat√≥rio de acur√°cia geral
    if all_comparisons:
        st.markdown("---")
        st.subheader("üìà Relat√≥rio de Acur√°cia da Rodada")
        
        accuracy_report = comparator.get_accuracy_report()
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("Acur√°cia 1X2", f"{accuracy_report['accuracy_1x2']:.1f}%")
        
        with col2:
            st.metric("Acur√°cia Over/Under", f"{accuracy_report['accuracy_over_under']:.1f}%")
        
        with col3:
            st.metric("Acur√°cia BTTS", f"{accuracy_report['accuracy_btts']:.1f}%")
        
        with col4:
            st.metric("Acur√°cia Geral", f"{accuracy_report['overall_accuracy']:.1f}%")
        
        # Sugest√µes de ajuste
        st.markdown("---")
        st.subheader("üîß Sugest√µes de Ajuste do Modelo")
        
        suggestions = comparator.suggest_model_adjustments(all_comparisons)
        
        if suggestions:
            for sug in suggestions:
                priority_color = {
                    'HIGH': 'üî¥',
                    'MEDIUM': 'üü°',
                    'LOW': 'üü¢'
                }.get(sug['priority'], '‚ö™')
                
                st.markdown(f"""
                **{priority_color} {sug['parameter']}**
                - Raz√£o: {sug['reason']}
                - Valor atual: {sug.get('current_value', sug.get('current_multiplier', 'N/A'))}
                - Valor sugerido: {sug.get('suggested_value', sug.get('suggested_multiplier', 'N/A'))}
                """)
            
            # Bot√£o para aplicar ajustes
            if st.button("‚úÖ Aplicar Ajustes Automaticamente"):
                result = calibrator.apply_adjustments(suggestions)
                
                if result['adjustments_made']:
                    st.success(f"‚úÖ {result['total_adjustments']} ajustes aplicados!")
                    
                    for adj in result['adjustments_made']:
                        st.info(f"**{adj['parameter']}:** {adj['old_value']} ‚Üí {adj['new_value']}")
                else:
                    st.warning("‚ö†Ô∏è Nenhum ajuste foi aplicado")
        else:
            st.success("‚úÖ Modelo est√° bem calibrado! Nenhum ajuste necess√°rio.")


def show_future_round_analysis(rodada: int, matches: List[Dict]):
    """
    An√°lise de rodada futura: Progn√≥sticos com odds
    
    Args:
        rodada: N√∫mero da rodada
        matches: Lista de jogos agendados
    """
    
    st.subheader("üîÆ Progn√≥sticos da Pr√≥xima Rodada")
    
    st.info(f"üìÖ Rodada {rodada} ainda n√£o come√ßou. Gerando progn√≥sticos...")
    
    # Inicializar coletor de odds
    try:
        odds_collector = OddsCollector()
        odds_available = True
    except:
        odds_available = False
        st.warning("‚ö†Ô∏è Odds API n√£o dispon√≠vel. Usando apenas modelos estat√≠sticos.")
    
    # Processar cada jogo
    for match in matches:
        with st.expander(f"‚öΩ {match['home_team']['name']} vs {match['away_team']['name']} - {format_match_date(match['date'])}"):
            
            # √Årbitro (se dispon√≠vel)
            if match.get('referee') and match['referee'] != 'N/A':
                st.markdown(f"**‚öñÔ∏è √Årbitro:** {match['referee']}")
                # TODO: Adicionar estat√≠sticas do √°rbitro quando implementado
            
            # Gerar progn√≥stico
            try:
                prognosis = generate_prognosis_for_match(match)
                
                # Buscar odds reais
                if odds_available:
                    odds_data = odds_collector.get_match_odds(
                        match['home_team']['name'],
                        match['away_team']['name']
                    )
                    
                    if odds_data:
                        display_odds_comparison(prognosis, odds_data)
                
                # Exibir progn√≥stico
                display_prognosis_summary(prognosis, match['home_team']['name'], match['away_team']['name'])
            
            except Exception as e:
                st.error(f"Erro ao gerar progn√≥stico: {e}")


def show_live_round_status(matches: List[Dict]):
    """
    Exibe status de rodada em andamento
    
    Args:
        matches: Lista de jogos
    """
    
    for match in matches:
        status_emoji = {
            'FINISHED': '‚úÖ',
            'IN_PLAY': '‚öΩ',
            'PAUSED': '‚è∏Ô∏è',
            'SCHEDULED': 'üìÖ',
            'TIMED': '‚è∞'
        }.get(match['status'], '‚ùì')
        
        if match['status'] == 'FINISHED':
            st.markdown(f"{status_emoji} **{match['home_team']['name']} {match['score']['home']}-{match['score']['away']} {match['away_team']['name']}**")
        else:
            st.markdown(f"{status_emoji} **{match['home_team']['name']} vs {match['away_team']['name']}** - {format_match_date(match['date'])}")


def generate_prognosis_for_match(match: Dict) -> Dict:
    """
    Gera progn√≥stico para um jogo espec√≠fico
    
    Args:
        match: Dados do jogo
        
    Returns:
        Dict com progn√≥stico completo
    """
    
    # Inicializar m√≥dulos
    collector = FootballDataCollector()
    processor = DataProcessor()
    calculator = PrognosisCalculator()
    
    # Buscar estat√≠sticas dos times
    home_stats = collector.calculate_team_stats(match['home_team']['id'], venue='HOME')
    away_stats = collector.calculate_team_stats(match['away_team']['id'], venue='AWAY')
    
    # Processar dados
    processed_data = processor.process_match_data(
        home_stats,
        away_stats,
        {},  # H2H vazio por enquanto
        match['home_team']['name'],
        match['away_team']['name']
    )
    
    # Calcular progn√≥stico
    prognosis = calculator.calculate_full_prognosis(
        processed_data['xG_home'],
        processed_data['xG_away'],
        match['home_team']['name'],
        match['away_team']['name']
    )
    
    return prognosis


def display_match_comparison(comparison: Dict):
    """Exibe compara√ß√£o de um jogo"""
    
    # √Årbitro
    if comparison['match'].get('referee') and comparison['match']['referee'] != 'N/A':
        st.markdown(f"**‚öñÔ∏è √Årbitro:** {comparison['match']['referee']}")
    
    # Resultado 1X2
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("**Progn√≥stico:**")
        acc = comparison['accuracy']['1x2']
        result_map = {'home': comparison['match']['home_team'], 'away': comparison['match']['away_team'], 'draw': 'Empate'}
        st.write(f"Resultado: {result_map.get(acc['predicted'], 'N/A')} ({acc['probability']*100:.1f}%)")
    
    with col2:
        st.markdown("**Realidade:**")
        st.write(f"Resultado: {result_map.get(acc['actual'], 'N/A')}")
        st.write("‚úÖ ACERTOU!" if acc['correct'] else "‚ùå ERROU")
    
    # Gols
    st.markdown("**Gols:**")
    goals = comparison['accuracy']['goals']
    st.write(f"Previsto: {goals['predicted']} | Real: {goals['actual']} | Erro: {goals['error']}")
    
    # Discrep√¢ncias
    if comparison['discrepancies']:
        st.warning(f"‚ö†Ô∏è {len(comparison['discrepancies'])} discrep√¢ncias detectadas")
        for disc in comparison['discrepancies']:
            st.markdown(f"- **{disc['market']}:** {disc['severity']}")


def display_odds_comparison(prognosis: Dict, odds_data: Dict):
    """Exibe compara√ß√£o entre progn√≥stico e odds"""
    
    st.markdown("### üí∞ Compara√ß√£o com Odds Reais")
    
    # Converter odds para probabilidades
    from data.odds_collector import OddsCollector
    odds_collector = OddsCollector()
    market_probs = odds_collector.get_market_probabilities(odds_data)
    
    # Comparar probabilidades
    col1, col2, col3 = st.columns(3)
    
    probs = prognosis['probabilities']
    
    with col1:
        st.metric("Mandante", 
                 f"Modelo: {probs['home_win']*100:.1f}%",
                 f"Odds: {market_probs['home_win']*100:.1f}%")
    
    with col2:
        st.metric("Empate",
                 f"Modelo: {probs['draw']*100:.1f}%",
                 f"Odds: {market_probs['draw']*100:.1f}%")
    
    with col3:
        st.metric("Visitante",
                 f"Modelo: {probs['away_win']*100:.1f}%",
                 f"Odds: {market_probs['away_win']*100:.1f}%")
    
    # Detectar value bets
    edges = {
        'home_win': probs['home_win'] - market_probs['home_win'],
        'draw': probs['draw'] - market_probs['draw'],
        'away_win': probs['away_win'] - market_probs['away_win']
    }
    
    max_edge = max(edges.values())
    
    if max_edge > 0.05:  # Edge > 5%
        best_market = max(edges, key=edges.get)
        st.success(f"üî• VALUE BET DETECTADO: {best_market.replace('_', ' ').title()} (Edge: {max_edge*100:.1f}%)")


def display_prognosis_summary(prognosis: Dict, home_team: str, away_team: str):
    """Exibe resumo do progn√≥stico"""
    
    probs = prognosis['probabilities']
    exp_goals = prognosis['expected_goals']
    
    # Resultado mais prov√°vel
    max_prob = max(probs['home_win'], probs['draw'], probs['away_win'])
    
    if probs['home_win'] == max_prob:
        result = f"Vit√≥ria {home_team}"
    elif probs['away_win'] == max_prob:
        result = f"Vit√≥ria {away_team}"
    else:
        result = "Empate"
    
    st.markdown(f"**üéØ Resultado Mais Prov√°vel:** {result} ({max_prob*100:.1f}%)")
    st.markdown(f"**‚öΩ Gols Esperados:** {home_team} {exp_goals['home']:.2f} x {exp_goals['away']:.2f} {away_team}")
    
    # Outros mercados
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown(f"**Over 2.5:** {probs.get('over_25', 0)*100:.1f}%")
    
    with col2:
        st.markdown(f"**BTTS:** {probs.get('btts', 0)*100:.1f}%")


def format_match_date(date_str: str) -> str:
    """Formata data do jogo"""
    try:
        dt = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
        return dt.strftime("%d/%m/%Y %H:%M")
    except:
        return date_str

